// Test suite for std.vec - Dynamic Array types
import std.io;
import std.vec;

i32 tests_passed = 0;
i32 tests_failed = 0;

void assert_true(bool cond, str msg) {
    if (cond) {
        tests_passed = tests_passed + 1;
        printf("  [PASS] %s\n", msg);
    } else {
        tests_failed = tests_failed + 1;
        printf("  [FAIL] %s\n", msg);
    }
}

void assert_eq_i32(i32 a, i32 b, str msg) {
    if (a == b) {
        tests_passed = tests_passed + 1;
        printf("  [PASS] %s\n", msg);
    } else {
        tests_failed = tests_failed + 1;
        printf("  [FAIL] %s (expected %d, got %d)\n", msg, b, a);
    }
}

void assert_eq_i64(i64 a, i64 b, str msg) {
    if (a == b) {
        tests_passed = tests_passed + 1;
        printf("  [PASS] %s\n", msg);
    } else {
        tests_failed = tests_failed + 1;
        printf("  [FAIL] %s (expected %ld, got %ld)\n", msg, b, a);
    }
}

i32 main() {
    printf("=== Vec<i32> Tests ===\n\n");
    
    // Test: Vector creation
    printf("--- Vector Creation ---\n");
    
    Vec<i32> v1 = Vec<i32>.new();
    assert_eq_i64(v1.length(), 0, "new() creates empty vector");
    assert_true(v1.is_empty(), "new() vector is_empty() returns true");
    
    Vec<i32> v2 = Vec<i32>.with_capacity(100);
    assert_eq_i64(v2.length(), 0, "with_capacity() creates empty vector");
    assert_true(v2.capacity >= 100, "with_capacity() reserves capacity");
    
    drop(v1);
    drop(v2);
    
    // Test: Push and access
    printf("\n--- Push and Access ---\n");
    
    Vec<i32> v3 = Vec<i32>.new();
    v3.push(10);
    assert_eq_i64(v3.length(), 1, "push() increases length");
    assert_eq_i32(v3.get(0), 10, "get() retrieves pushed value");
    
    v3.push(20);
    v3.push(30);
    assert_eq_i64(v3.length(), 3, "multiple pushes update length");
    assert_eq_i32(v3.get(1), 20, "get(1) retrieves second element");
    assert_eq_i32(v3.get(2), 30, "get(2) retrieves third element");
    
    assert_eq_i32(v3.first(), 10, "first() returns first element");
    assert_eq_i32(v3.last(), 30, "last() returns last element");
    
    drop(v3);
    
    // Test: Set
    printf("\n--- Set ---\n");
    
    Vec<i32> v4 = Vec<i32>.new();
    v4.push(1);
    v4.push(2);
    v4.push(3);
    
    v4.set(1, 99);
    assert_eq_i32(v4.get(1), 99, "set() modifies element");
    assert_eq_i32(v4.get(0), 1, "set() doesn't affect other elements");
    assert_eq_i32(v4.get(2), 3, "set() doesn't affect other elements");
    
    drop(v4);
    
    // Test: Pop
    printf("\n--- Pop ---\n");
    
    Vec<i32> v5 = Vec<i32>.new();
    v5.push(1);
    v5.push(2);
    v5.push(3);
    
    i32 popped = v5.pop();
    assert_eq_i32(popped, 3, "pop() returns last element");
    assert_eq_i64(v5.length(), 2, "pop() decreases length");
    
    popped = v5.pop();
    assert_eq_i32(popped, 2, "second pop() returns next last");
    
    drop(v5);
    
    // Test: Find and contains
    printf("\n--- Find and Contains ---\n");
    
    Vec<i32> v8 = Vec<i32>.new();
    v8.push(5);
    v8.push(10);
    v8.push(15);
    v8.push(10);  // duplicate
    
    assert_eq_i64(v8.find(10), 1, "find() returns first occurrence");
    assert_eq_i64(v8.find(15), 2, "find() locates element");
    assert_eq_i64(v8.find(999), -1, "find() returns -1 for not found");
    
    assert_true(v8.contains(10), "contains() returns true for existing");
    assert_true(!v8.contains(999), "contains() returns false for missing");
    
    drop(v8);
    
    // Test: Reverse
    printf("\n--- Reverse ---\n");
    
    Vec<i32> v9 = Vec<i32>.new();
    v9.push(1);
    v9.push(2);
    v9.push(3);
    v9.push(4);
    
    v9.reverse();
    assert_eq_i32(v9.get(0), 4, "reverse() moves last to first");
    assert_eq_i32(v9.get(1), 3, "reverse() swaps elements");
    assert_eq_i32(v9.get(2), 2, "reverse() swaps elements");
    assert_eq_i32(v9.get(3), 1, "reverse() moves first to last");
    
    drop(v9);
    
    // Test: Clear
    printf("\n--- Clear ---\n");
    
    Vec<i32> v10 = Vec<i32>.new();
    v10.push(1);
    v10.push(2);
    v10.push(3);
    i64 old_cap = v10.capacity;
    
    v10.clear();
    assert_eq_i64(v10.length(), 0, "clear() sets length to 0");
    assert_true(v10.is_empty(), "clear() makes vector empty");
    assert_true(v10.capacity == old_cap, "clear() preserves capacity");
    
    drop(v10);
    
    // Test: Capacity growth
    printf("\n--- Capacity Growth ---\n");
    
    Vec<i32> v11 = Vec<i32>.new();
    i64 initial_cap = v11.capacity;
    
    // Push more elements than initial capacity
    for (i32 i = 0; i < 100; i = i + 1) {
        v11.push(i);
    }
    
    assert_eq_i64(v11.length(), 100, "vector grows to hold 100 elements");
    assert_true(v11.capacity > initial_cap, "capacity increased");
    
    // Verify all elements
    bool all_correct = true;
    for (i32 i = 0; i < 100; i = i + 1) {
        if (v11.get(i) != i) {
            all_correct = false;
        }
    }
    assert_true(all_correct, "all pushed elements have correct values");
    
    drop(v11);
    
    // Test: Vec<f64>
    printf("\n=== Vec<f64> Tests ===\n\n");
    
    Vec<f64> vf = Vec<f64>.new();
    vf.push(1.0);
    vf.push(2.0);
    vf.push(3.0);
    vf.push(4.0);
    vf.push(5.0);
    
    assert_eq_i64(vf.length(), 5, "Vec<f64> stores correct number of elements");
    
    drop(vf);
    
    // Test: Vec<void*>
    printf("\n=== Vec<void*> Tests ===\n\n");
    
    Vec<void*> vp = Vec<void*>.new();
    i32 a = 10;
    i32 b = 20;
    
    vp.push(&a);
    vp.push(&b);
    
    assert_eq_i64(vp.length(), 2, "Vec<void*> stores pointers");
    
    i32* p1 = (i32*)(vp.get(0));
    i32* p2 = (i32*)(vp.get(1));
    assert_eq_i32(*p1, 10, "Vec<void*> retrieves correct pointer (1)");
    assert_eq_i32(*p2, 20, "Vec<void*> retrieves correct pointer (2)");
    
    drop(vp);
    
    // Summary
    printf("\n=== Results ===\n");
    printf("Passed: %d\n", tests_passed);
    printf("Failed: %d\n", tests_failed);
    
    return tests_failed > 0 ? 1 : 0;
}
