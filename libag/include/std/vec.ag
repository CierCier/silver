// Silver Standard Library - Dynamic Array (Vector) Type
// A generic dynamic array with automatic memory management

import std.io;
import std.mem;

// Drop trait for automatic cleanup
trait Drop {
    void drop();
}

// Generic Vector
@trait(drop)
struct Vec<T> {
    T* data;        // Underlying array
    i64 len;        // Current number of elements
    i64 capacity;   // Allocated capacity
}

impl Vec<T> {
    // Create a new empty vector
    Vec<T> new() {
        Vec<T> v;
        v.capacity = 8;
        v.len = 0;
        v.data = alloc<T>(8);
        return v;
    }

    // Create a vector with specified capacity
    Vec<T> with_capacity(i64 cap) {
        Vec<T> v;
        if (cap < 1) {
            cap = 1;
        }
        v.capacity = cap;
        v.len = 0;
        v.data = alloc<T>(cap);
        return v;
    }

    // Drop implementation
    void drop(Vec<T> self) {
        if (self.data != 0) {
            free(self.data);
        }
    }

    // Get length
    i64 length(Vec<T> self) {
        return self.len;
    }

    // Check if empty
    bool is_empty(Vec<T> self) {
        return self.len == 0;
    }

    // Get element at index (no bounds checking)
    T get(Vec<T> self, i64 index) {
        return self.data[index];
    }

    // Set element at index (no bounds checking)
    void set(Vec<T>* self, i64 index, T value) {
        self->data[index] = value;
    }

    // Reserve capacity
    void reserve(Vec<T>* self, i64 new_cap) {
        if (new_cap <= self->capacity) {
            return;
        }
        T* new_data = alloc<T>(new_cap);
        for (i64 i = 0; i < self->len; i = i + 1) {
            new_data[i] = self->data[i];
        }
        free(self->data);
        self->data = new_data;
        self->capacity = new_cap;
    }

    // Push an element to the back
    void push(Vec<T>* self, T value) {
        if (self->len >= self->capacity) {
            self->reserve(self->capacity * 2);
        }
        self->data[self->len] = value;
        self->len = self->len + 1;
    }

    // Pop an element from the back
    T pop(Vec<T>* self) {
        if (self->len == 0) {
            return new<T>(); // Zero value
        }
        self->len = self->len - 1;
        return self->data[self->len];
    }

    // Clear all elements (keeps capacity)
    void clear(Vec<T>* self) {
        self->len = 0;
    }

    // Get first element
    T first(Vec<T> self) {
        return self.data[0];
    }

    // Get last element
    T last(Vec<T> self) {
        return self.data[self.len - 1];
    }

    // Reverse the vector in place
    void reverse(Vec<T>* self) {
        i64 i = 0;
        i64 j = self->len - 1;
        while (i < j) {
            T tmp = self->data[i];
            self->data[i] = self->data[j];
            self->data[j] = tmp;
            i = i + 1;
            j = j - 1;
        }
    }
    
    // Find first occurrence of value, returns -1 if not found
    // Note: This requires T to be comparable, which we can't enforce yet
    // But it will work if T supports ==
    i64 find(Vec<T> self, T value) {
        for (i64 i = 0; i < self.len; i = i + 1) {
            if (self.data[i] == value) {
                return i;
            }
        }
        return -1;
    }
    
    // Check if contains value
    bool contains(Vec<T> self, T value) {
        return self.find(value) >= 0;
    }
}
